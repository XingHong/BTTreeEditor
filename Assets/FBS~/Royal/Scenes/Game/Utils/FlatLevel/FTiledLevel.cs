// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Royal.Scenes.Game.Utils.FlatLevel
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct FTiledLevel : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_23_5_26(); }
  public static FTiledLevel GetRootAsFTiledLevel(ByteBuffer _bb) { return GetRootAsFTiledLevel(_bb, new FTiledLevel()); }
  public static FTiledLevel GetRootAsFTiledLevel(ByteBuffer _bb, FTiledLevel obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public static bool VerifyFTiledLevel(ByteBuffer _bb) {Google.FlatBuffers.Verifier verifier = new Google.FlatBuffers.Verifier(_bb); return verifier.VerifyBuffer("", false, FTiledLevelVerify.Verify); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public FTiledLevel __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public int Move { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FGoalData? Goals(int j) { int o = __p.__offset(8); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FGoalData?)(new Royal.Scenes.Game.Utils.FlatLevel.FGoalData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int GoalsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid? Grid { get { int o = __p.__offset(10); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid?)(new Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined? Predefined(int j) { int o = __p.__offset(12); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined?)(new Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PredefinedLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FTiledSet? Sets(int j) { int o = __p.__offset(14); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FTiledSet?)(new Royal.Scenes.Game.Utils.FlatLevel.FTiledSet()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SetsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int Colors(int j) { int o = __p.__offset(16); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int ColorsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetColorsBytes() { return __p.__vector_as_span<int>(16, 4); }
#else
  public ArraySegment<byte>? GetColorsBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public int[] GetColorsArray() { return __p.__vector_as_array<int>(16); }
  public Royal.Scenes.Game.Utils.FlatLevel.FItemCount? Counts(int j) { int o = __p.__offset(18); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FItemCount?)(new Royal.Scenes.Game.Utils.FlatLevel.FItemCount()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CountsLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FPotionColor? PotionColors(int j) { int o = __p.__offset(20); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FPotionColor?)(new Royal.Scenes.Game.Utils.FlatLevel.FPotionColor()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PotionColorsLength { get { int o = __p.__offset(20); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int LowMatch(int j) { int o = __p.__offset(22); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int LowMatchLength { get { int o = __p.__offset(22); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetLowMatchBytes() { return __p.__vector_as_span<int>(22, 4); }
#else
  public ArraySegment<byte>? GetLowMatchBytes() { return __p.__vector_as_arraysegment(22); }
#endif
  public int[] GetLowMatchArray() { return __p.__vector_as_array<int>(22); }
  public Royal.Scenes.Game.Utils.FlatLevel.FCurtainData? Curtains(int j) { int o = __p.__offset(24); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCurtainData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCurtainData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CurtainsLength { get { int o = __p.__offset(24); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData? CupShelves(int j) { int o = __p.__offset(26); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CupShelvesLength { get { int o = __p.__offset(26); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData? SoilGroups(int j) { int o = __p.__offset(28); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SoilGroupsLength { get { int o = __p.__offset(28); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FDrillData? Drills(int j) { int o = __p.__offset(30); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FDrillData?)(new Royal.Scenes.Game.Utils.FlatLevel.FDrillData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int DrillsLength { get { int o = __p.__offset(30); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int LightBulbColorOrder(int j) { int o = __p.__offset(32); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int LightBulbColorOrderLength { get { int o = __p.__offset(32); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetLightBulbColorOrderBytes() { return __p.__vector_as_span<int>(32, 4); }
#else
  public ArraySegment<byte>? GetLightBulbColorOrderBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public int[] GetLightBulbColorOrderArray() { return __p.__vector_as_array<int>(32); }
  public int ChainCount { get { int o = __p.__offset(34); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool PropellerIgnoresChain { get { int o = __p.__offset(36); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig? PouchConfig { get { int o = __p.__offset(38); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig?)(new Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FLimitData? Limits(int j) { int o = __p.__offset(40); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FLimitData?)(new Royal.Scenes.Game.Utils.FlatLevel.FLimitData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int LimitsLength { get { int o = __p.__offset(40); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool PropellerIgnoresDrill { get { int o = __p.__offset(42); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public int JellyReceivableCellCount { get { int o = __p.__offset(44); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public bool HasHoleInGrid { get { int o = __p.__offset(46); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData? Treasuremaps(int j) { int o = __p.__offset(48); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TreasuremapsLength { get { int o = __p.__offset(48); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig? Slots(int j) { int o = __p.__offset(50); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig?)(new Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int SlotsLength { get { int o = __p.__offset(50); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int CageCount { get { int o = __p.__offset(52); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData? MagnetGroups(int j) { int o = __p.__offset(54); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int MagnetGroupsLength { get { int o = __p.__offset(54); return o != 0 ? __p.__vector_len(o) : 0; } }
  public bool Scroll { get { int o = __p.__offset(56); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData? ConveyorBelts(int j) { int o = __p.__offset(58); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ConveyorBeltsLength { get { int o = __p.__offset(58); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FCurtainData? Coils(int j) { int o = __p.__offset(60); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCurtainData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCurtainData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CoilsLength { get { int o = __p.__offset(60); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData? CandyCaneGroups(int j) { int o = __p.__offset(62); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CandyCaneGroupsLength { get { int o = __p.__offset(62); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData? TabletItemGroups(int j) { int o = __p.__offset(64); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TabletItemGroupsLength { get { int o = __p.__offset(64); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData? IvyItemGroups(int j) { int o = __p.__offset(66); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int IvyItemGroupsLength { get { int o = __p.__offset(66); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData? BlindsGroups(int j) { int o = __p.__offset(68); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BlindsGroupsLength { get { int o = __p.__offset(68); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FWaterData? WaterData { get { int o = __p.__offset(70); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FWaterData?)(new Royal.Scenes.Game.Utils.FlatLevel.FWaterData()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FShifterData? ShifterGrids(int j) { int o = __p.__offset(72); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FShifterData?)(new Royal.Scenes.Game.Utils.FlatLevel.FShifterData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ShifterGridsLength { get { int o = __p.__offset(72); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData? PorcelainGroups(int j) { int o = __p.__offset(74); return o != 0 ? (Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData?)(new Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PorcelainGroupsLength { get { int o = __p.__offset(74); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel> CreateFTiledLevel(FlatBufferBuilder builder,
      StringOffset NameOffset = default(StringOffset),
      int Move = 0,
      VectorOffset GoalsOffset = default(VectorOffset),
      Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid> GridOffset = default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid>),
      VectorOffset PredefinedOffset = default(VectorOffset),
      VectorOffset SetsOffset = default(VectorOffset),
      VectorOffset ColorsOffset = default(VectorOffset),
      VectorOffset CountsOffset = default(VectorOffset),
      VectorOffset PotionColorsOffset = default(VectorOffset),
      VectorOffset LowMatchOffset = default(VectorOffset),
      VectorOffset CurtainsOffset = default(VectorOffset),
      VectorOffset CupShelvesOffset = default(VectorOffset),
      VectorOffset SoilGroupsOffset = default(VectorOffset),
      VectorOffset DrillsOffset = default(VectorOffset),
      VectorOffset LightBulbColorOrderOffset = default(VectorOffset),
      int ChainCount = 0,
      bool PropellerIgnoresChain = false,
      Offset<Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig> PouchConfigOffset = default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig>),
      VectorOffset LimitsOffset = default(VectorOffset),
      bool PropellerIgnoresDrill = false,
      int JellyReceivableCellCount = 0,
      bool HasHoleInGrid = false,
      VectorOffset TreasuremapsOffset = default(VectorOffset),
      VectorOffset SlotsOffset = default(VectorOffset),
      int CageCount = 0,
      VectorOffset MagnetGroupsOffset = default(VectorOffset),
      bool Scroll = false,
      VectorOffset ConveyorBeltsOffset = default(VectorOffset),
      VectorOffset CoilsOffset = default(VectorOffset),
      VectorOffset CandyCaneGroupsOffset = default(VectorOffset),
      VectorOffset TabletItemGroupsOffset = default(VectorOffset),
      VectorOffset IvyItemGroupsOffset = default(VectorOffset),
      VectorOffset BlindsGroupsOffset = default(VectorOffset),
      Offset<Royal.Scenes.Game.Utils.FlatLevel.FWaterData> WaterDataOffset = default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FWaterData>),
      VectorOffset ShifterGridsOffset = default(VectorOffset),
      VectorOffset PorcelainGroupsOffset = default(VectorOffset)) {
    builder.StartTable(36);
    FTiledLevel.AddPorcelainGroups(builder, PorcelainGroupsOffset);
    FTiledLevel.AddShifterGrids(builder, ShifterGridsOffset);
    FTiledLevel.AddWaterData(builder, WaterDataOffset);
    FTiledLevel.AddBlindsGroups(builder, BlindsGroupsOffset);
    FTiledLevel.AddIvyItemGroups(builder, IvyItemGroupsOffset);
    FTiledLevel.AddTabletItemGroups(builder, TabletItemGroupsOffset);
    FTiledLevel.AddCandyCaneGroups(builder, CandyCaneGroupsOffset);
    FTiledLevel.AddCoils(builder, CoilsOffset);
    FTiledLevel.AddConveyorBelts(builder, ConveyorBeltsOffset);
    FTiledLevel.AddMagnetGroups(builder, MagnetGroupsOffset);
    FTiledLevel.AddCageCount(builder, CageCount);
    FTiledLevel.AddSlots(builder, SlotsOffset);
    FTiledLevel.AddTreasuremaps(builder, TreasuremapsOffset);
    FTiledLevel.AddJellyReceivableCellCount(builder, JellyReceivableCellCount);
    FTiledLevel.AddLimits(builder, LimitsOffset);
    FTiledLevel.AddPouchConfig(builder, PouchConfigOffset);
    FTiledLevel.AddChainCount(builder, ChainCount);
    FTiledLevel.AddLightBulbColorOrder(builder, LightBulbColorOrderOffset);
    FTiledLevel.AddDrills(builder, DrillsOffset);
    FTiledLevel.AddSoilGroups(builder, SoilGroupsOffset);
    FTiledLevel.AddCupShelves(builder, CupShelvesOffset);
    FTiledLevel.AddCurtains(builder, CurtainsOffset);
    FTiledLevel.AddLowMatch(builder, LowMatchOffset);
    FTiledLevel.AddPotionColors(builder, PotionColorsOffset);
    FTiledLevel.AddCounts(builder, CountsOffset);
    FTiledLevel.AddColors(builder, ColorsOffset);
    FTiledLevel.AddSets(builder, SetsOffset);
    FTiledLevel.AddPredefined(builder, PredefinedOffset);
    FTiledLevel.AddGrid(builder, GridOffset);
    FTiledLevel.AddGoals(builder, GoalsOffset);
    FTiledLevel.AddMove(builder, Move);
    FTiledLevel.AddName(builder, NameOffset);
    FTiledLevel.AddScroll(builder, Scroll);
    FTiledLevel.AddHasHoleInGrid(builder, HasHoleInGrid);
    FTiledLevel.AddPropellerIgnoresDrill(builder, PropellerIgnoresDrill);
    FTiledLevel.AddPropellerIgnoresChain(builder, PropellerIgnoresChain);
    return FTiledLevel.EndFTiledLevel(builder);
  }

  public static void StartFTiledLevel(FlatBufferBuilder builder) { builder.StartTable(36); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddMove(FlatBufferBuilder builder, int move) { builder.AddInt(1, move, 0); }
  public static void AddGoals(FlatBufferBuilder builder, VectorOffset goalsOffset) { builder.AddOffset(2, goalsOffset.Value, 0); }
  public static VectorOffset CreateGoalsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FGoalData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FGoalData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FGoalData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateGoalsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FGoalData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartGoalsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGrid(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid> gridOffset) { builder.AddOffset(3, gridOffset.Value, 0); }
  public static void AddPredefined(FlatBufferBuilder builder, VectorOffset predefinedOffset) { builder.AddOffset(4, predefinedOffset.Value, 0); }
  public static VectorOffset CreatePredefinedVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePredefinedVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePredefinedVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePredefinedVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPredefinedVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSets(FlatBufferBuilder builder, VectorOffset setsOffset) { builder.AddOffset(5, setsOffset.Value, 0); }
  public static VectorOffset CreateSetsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledSet>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSetsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledSet>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSetsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledSet>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSetsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledSet>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSetsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddColors(FlatBufferBuilder builder, VectorOffset colorsOffset) { builder.AddOffset(6, colorsOffset.Value, 0); }
  public static VectorOffset CreateColorsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateColorsVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateColorsVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateColorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartColorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCounts(FlatBufferBuilder builder, VectorOffset countsOffset) { builder.AddOffset(7, countsOffset.Value, 0); }
  public static VectorOffset CreateCountsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FItemCount>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCountsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FItemCount>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCountsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FItemCount>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCountsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FItemCount>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCountsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPotionColors(FlatBufferBuilder builder, VectorOffset potionColorsOffset) { builder.AddOffset(8, potionColorsOffset.Value, 0); }
  public static VectorOffset CreatePotionColorsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FPotionColor>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePotionColorsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FPotionColor>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePotionColorsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FPotionColor>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePotionColorsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FPotionColor>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPotionColorsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLowMatch(FlatBufferBuilder builder, VectorOffset lowMatchOffset) { builder.AddOffset(9, lowMatchOffset.Value, 0); }
  public static VectorOffset CreateLowMatchVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLowMatchVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLowMatchVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLowMatchVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLowMatchVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCurtains(FlatBufferBuilder builder, VectorOffset curtainsOffset) { builder.AddOffset(10, curtainsOffset.Value, 0); }
  public static VectorOffset CreateCurtainsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCurtainsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCurtainsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCurtainsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCurtainsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCupShelves(FlatBufferBuilder builder, VectorOffset cupShelvesOffset) { builder.AddOffset(11, cupShelvesOffset.Value, 0); }
  public static VectorOffset CreateCupShelvesVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCupShelvesVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCupShelvesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCupShelvesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCupShelvesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSoilGroups(FlatBufferBuilder builder, VectorOffset soilGroupsOffset) { builder.AddOffset(12, soilGroupsOffset.Value, 0); }
  public static VectorOffset CreateSoilGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSoilGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSoilGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSoilGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSoilGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddDrills(FlatBufferBuilder builder, VectorOffset drillsOffset) { builder.AddOffset(13, drillsOffset.Value, 0); }
  public static VectorOffset CreateDrillsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FDrillData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateDrillsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FDrillData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDrillsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FDrillData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDrillsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FDrillData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDrillsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddLightBulbColorOrder(FlatBufferBuilder builder, VectorOffset lightBulbColorOrderOffset) { builder.AddOffset(14, lightBulbColorOrderOffset.Value, 0); }
  public static VectorOffset CreateLightBulbColorOrderVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateLightBulbColorOrderVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLightBulbColorOrderVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLightBulbColorOrderVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLightBulbColorOrderVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddChainCount(FlatBufferBuilder builder, int chainCount) { builder.AddInt(15, chainCount, 0); }
  public static void AddPropellerIgnoresChain(FlatBufferBuilder builder, bool propellerIgnoresChain) { builder.AddBool(16, propellerIgnoresChain, false); }
  public static void AddPouchConfig(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig> pouchConfigOffset) { builder.AddOffset(17, pouchConfigOffset.Value, 0); }
  public static void AddLimits(FlatBufferBuilder builder, VectorOffset limitsOffset) { builder.AddOffset(18, limitsOffset.Value, 0); }
  public static VectorOffset CreateLimitsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FLimitData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateLimitsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FLimitData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLimitsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FLimitData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateLimitsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FLimitData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartLimitsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPropellerIgnoresDrill(FlatBufferBuilder builder, bool propellerIgnoresDrill) { builder.AddBool(19, propellerIgnoresDrill, false); }
  public static void AddJellyReceivableCellCount(FlatBufferBuilder builder, int jellyReceivableCellCount) { builder.AddInt(20, jellyReceivableCellCount, 0); }
  public static void AddHasHoleInGrid(FlatBufferBuilder builder, bool hasHoleInGrid) { builder.AddBool(21, hasHoleInGrid, false); }
  public static void AddTreasuremaps(FlatBufferBuilder builder, VectorOffset treasuremapsOffset) { builder.AddOffset(22, treasuremapsOffset.Value, 0); }
  public static VectorOffset CreateTreasuremapsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTreasuremapsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTreasuremapsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTreasuremapsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTreasuremapsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddSlots(FlatBufferBuilder builder, VectorOffset slotsOffset) { builder.AddOffset(23, slotsOffset.Value, 0); }
  public static VectorOffset CreateSlotsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateSlotsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSlotsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSlotsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSlotsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCageCount(FlatBufferBuilder builder, int cageCount) { builder.AddInt(24, cageCount, 0); }
  public static void AddMagnetGroups(FlatBufferBuilder builder, VectorOffset magnetGroupsOffset) { builder.AddOffset(25, magnetGroupsOffset.Value, 0); }
  public static VectorOffset CreateMagnetGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateMagnetGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMagnetGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateMagnetGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartMagnetGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddScroll(FlatBufferBuilder builder, bool scroll) { builder.AddBool(26, scroll, false); }
  public static void AddConveyorBelts(FlatBufferBuilder builder, VectorOffset conveyorBeltsOffset) { builder.AddOffset(27, conveyorBeltsOffset.Value, 0); }
  public static VectorOffset CreateConveyorBeltsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateConveyorBeltsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConveyorBeltsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateConveyorBeltsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartConveyorBeltsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCoils(FlatBufferBuilder builder, VectorOffset coilsOffset) { builder.AddOffset(28, coilsOffset.Value, 0); }
  public static VectorOffset CreateCoilsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCoilsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCoilsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCoilsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCoilsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCandyCaneGroups(FlatBufferBuilder builder, VectorOffset candyCaneGroupsOffset) { builder.AddOffset(29, candyCaneGroupsOffset.Value, 0); }
  public static VectorOffset CreateCandyCaneGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCandyCaneGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCandyCaneGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCandyCaneGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCandyCaneGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTabletItemGroups(FlatBufferBuilder builder, VectorOffset tabletItemGroupsOffset) { builder.AddOffset(30, tabletItemGroupsOffset.Value, 0); }
  public static VectorOffset CreateTabletItemGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTabletItemGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTabletItemGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTabletItemGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTabletItemGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIvyItemGroups(FlatBufferBuilder builder, VectorOffset ivyItemGroupsOffset) { builder.AddOffset(31, ivyItemGroupsOffset.Value, 0); }
  public static VectorOffset CreateIvyItemGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateIvyItemGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIvyItemGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIvyItemGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartIvyItemGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBlindsGroups(FlatBufferBuilder builder, VectorOffset blindsGroupsOffset) { builder.AddOffset(32, blindsGroupsOffset.Value, 0); }
  public static VectorOffset CreateBlindsGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBlindsGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBlindsGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBlindsGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBlindsGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddWaterData(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FWaterData> waterDataOffset) { builder.AddOffset(33, waterDataOffset.Value, 0); }
  public static void AddShifterGrids(FlatBufferBuilder builder, VectorOffset shifterGridsOffset) { builder.AddOffset(34, shifterGridsOffset.Value, 0); }
  public static VectorOffset CreateShifterGridsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FShifterData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateShifterGridsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FShifterData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShifterGridsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FShifterData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShifterGridsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FShifterData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShifterGridsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPorcelainGroups(FlatBufferBuilder builder, VectorOffset porcelainGroupsOffset) { builder.AddOffset(35, porcelainGroupsOffset.Value, 0); }
  public static VectorOffset CreatePorcelainGroupsVector(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePorcelainGroupsVectorBlock(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePorcelainGroupsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePorcelainGroupsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPorcelainGroupsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel> EndFTiledLevel(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel>(o);
  }
  public static void FinishFTiledLevelBuffer(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedFTiledLevelBuffer(FlatBufferBuilder builder, Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel> offset) { builder.FinishSizePrefixed(offset.Value); }
  public FTiledLevelT UnPack() {
    var _o = new FTiledLevelT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FTiledLevelT _o) {
    _o.Name = this.Name;
    _o.Move = this.Move;
    _o.Goals = new List<Royal.Scenes.Game.Utils.FlatLevel.FGoalDataT>();
    for (var _j = 0; _j < this.GoalsLength; ++_j) {_o.Goals.Add(this.Goals(_j).HasValue ? this.Goals(_j).Value.UnPack() : null);}
    _o.Grid = this.Grid.HasValue ? this.Grid.Value.UnPack() : null;
    _o.Predefined = new List<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefinedT>();
    for (var _j = 0; _j < this.PredefinedLength; ++_j) {_o.Predefined.Add(this.Predefined(_j).HasValue ? this.Predefined(_j).Value.UnPack() : null);}
    _o.Sets = new List<Royal.Scenes.Game.Utils.FlatLevel.FTiledSetT>();
    for (var _j = 0; _j < this.SetsLength; ++_j) {_o.Sets.Add(this.Sets(_j).HasValue ? this.Sets(_j).Value.UnPack() : null);}
    _o.Colors = new List<int>();
    for (var _j = 0; _j < this.ColorsLength; ++_j) {_o.Colors.Add(this.Colors(_j));}
    _o.Counts = new List<Royal.Scenes.Game.Utils.FlatLevel.FItemCountT>();
    for (var _j = 0; _j < this.CountsLength; ++_j) {_o.Counts.Add(this.Counts(_j).HasValue ? this.Counts(_j).Value.UnPack() : null);}
    _o.PotionColors = new List<Royal.Scenes.Game.Utils.FlatLevel.FPotionColorT>();
    for (var _j = 0; _j < this.PotionColorsLength; ++_j) {_o.PotionColors.Add(this.PotionColors(_j).HasValue ? this.PotionColors(_j).Value.UnPack() : null);}
    _o.LowMatch = new List<int>();
    for (var _j = 0; _j < this.LowMatchLength; ++_j) {_o.LowMatch.Add(this.LowMatch(_j));}
    _o.Curtains = new List<Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataT>();
    for (var _j = 0; _j < this.CurtainsLength; ++_j) {_o.Curtains.Add(this.Curtains(_j).HasValue ? this.Curtains(_j).Value.UnPack() : null);}
    _o.CupShelves = new List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT>();
    for (var _j = 0; _j < this.CupShelvesLength; ++_j) {_o.CupShelves.Add(this.CupShelves(_j).HasValue ? this.CupShelves(_j).Value.UnPack() : null);}
    _o.SoilGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT>();
    for (var _j = 0; _j < this.SoilGroupsLength; ++_j) {_o.SoilGroups.Add(this.SoilGroups(_j).HasValue ? this.SoilGroups(_j).Value.UnPack() : null);}
    _o.Drills = new List<Royal.Scenes.Game.Utils.FlatLevel.FDrillDataT>();
    for (var _j = 0; _j < this.DrillsLength; ++_j) {_o.Drills.Add(this.Drills(_j).HasValue ? this.Drills(_j).Value.UnPack() : null);}
    _o.LightBulbColorOrder = new List<int>();
    for (var _j = 0; _j < this.LightBulbColorOrderLength; ++_j) {_o.LightBulbColorOrder.Add(this.LightBulbColorOrder(_j));}
    _o.ChainCount = this.ChainCount;
    _o.PropellerIgnoresChain = this.PropellerIgnoresChain;
    _o.PouchConfig = this.PouchConfig.HasValue ? this.PouchConfig.Value.UnPack() : null;
    _o.Limits = new List<Royal.Scenes.Game.Utils.FlatLevel.FLimitDataT>();
    for (var _j = 0; _j < this.LimitsLength; ++_j) {_o.Limits.Add(this.Limits(_j).HasValue ? this.Limits(_j).Value.UnPack() : null);}
    _o.PropellerIgnoresDrill = this.PropellerIgnoresDrill;
    _o.JellyReceivableCellCount = this.JellyReceivableCellCount;
    _o.HasHoleInGrid = this.HasHoleInGrid;
    _o.Treasuremaps = new List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT>();
    for (var _j = 0; _j < this.TreasuremapsLength; ++_j) {_o.Treasuremaps.Add(this.Treasuremaps(_j).HasValue ? this.Treasuremaps(_j).Value.UnPack() : null);}
    _o.Slots = new List<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfigT>();
    for (var _j = 0; _j < this.SlotsLength; ++_j) {_o.Slots.Add(this.Slots(_j).HasValue ? this.Slots(_j).Value.UnPack() : null);}
    _o.CageCount = this.CageCount;
    _o.MagnetGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT>();
    for (var _j = 0; _j < this.MagnetGroupsLength; ++_j) {_o.MagnetGroups.Add(this.MagnetGroups(_j).HasValue ? this.MagnetGroups(_j).Value.UnPack() : null);}
    _o.Scroll = this.Scroll;
    _o.ConveyorBelts = new List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT>();
    for (var _j = 0; _j < this.ConveyorBeltsLength; ++_j) {_o.ConveyorBelts.Add(this.ConveyorBelts(_j).HasValue ? this.ConveyorBelts(_j).Value.UnPack() : null);}
    _o.Coils = new List<Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataT>();
    for (var _j = 0; _j < this.CoilsLength; ++_j) {_o.Coils.Add(this.Coils(_j).HasValue ? this.Coils(_j).Value.UnPack() : null);}
    _o.CandyCaneGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT>();
    for (var _j = 0; _j < this.CandyCaneGroupsLength; ++_j) {_o.CandyCaneGroups.Add(this.CandyCaneGroups(_j).HasValue ? this.CandyCaneGroups(_j).Value.UnPack() : null);}
    _o.TabletItemGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT>();
    for (var _j = 0; _j < this.TabletItemGroupsLength; ++_j) {_o.TabletItemGroups.Add(this.TabletItemGroups(_j).HasValue ? this.TabletItemGroups(_j).Value.UnPack() : null);}
    _o.IvyItemGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT>();
    for (var _j = 0; _j < this.IvyItemGroupsLength; ++_j) {_o.IvyItemGroups.Add(this.IvyItemGroups(_j).HasValue ? this.IvyItemGroups(_j).Value.UnPack() : null);}
    _o.BlindsGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupDataT>();
    for (var _j = 0; _j < this.BlindsGroupsLength; ++_j) {_o.BlindsGroups.Add(this.BlindsGroups(_j).HasValue ? this.BlindsGroups(_j).Value.UnPack() : null);}
    _o.WaterData = this.WaterData.HasValue ? this.WaterData.Value.UnPack() : null;
    _o.ShifterGrids = new List<Royal.Scenes.Game.Utils.FlatLevel.FShifterDataT>();
    for (var _j = 0; _j < this.ShifterGridsLength; ++_j) {_o.ShifterGrids.Add(this.ShifterGrids(_j).HasValue ? this.ShifterGrids(_j).Value.UnPack() : null);}
    _o.PorcelainGroups = new List<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupDataT>();
    for (var _j = 0; _j < this.PorcelainGroupsLength; ++_j) {_o.PorcelainGroups.Add(this.PorcelainGroups(_j).HasValue ? this.PorcelainGroups(_j).Value.UnPack() : null);}
  }
  public static Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel> Pack(FlatBufferBuilder builder, FTiledLevelT _o) {
    if (_o == null) return default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledLevel>);
    var _Name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _Goals = default(VectorOffset);
    if (_o.Goals != null) {
      var __Goals = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FGoalData>[_o.Goals.Count];
      for (var _j = 0; _j < __Goals.Length; ++_j) { __Goals[_j] = Royal.Scenes.Game.Utils.FlatLevel.FGoalData.Pack(builder, _o.Goals[_j]); }
      _Goals = CreateGoalsVector(builder, __Goals);
    }
    var _Grid = _o.Grid == null ? default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid>) : Royal.Scenes.Game.Utils.FlatLevel.FTiledGrid.Pack(builder, _o.Grid);
    var _Predefined = default(VectorOffset);
    if (_o.Predefined != null) {
      var __Predefined = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined>[_o.Predefined.Count];
      for (var _j = 0; _j < __Predefined.Length; ++_j) { __Predefined[_j] = Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefined.Pack(builder, _o.Predefined[_j]); }
      _Predefined = CreatePredefinedVector(builder, __Predefined);
    }
    var _Sets = default(VectorOffset);
    if (_o.Sets != null) {
      var __Sets = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FTiledSet>[_o.Sets.Count];
      for (var _j = 0; _j < __Sets.Length; ++_j) { __Sets[_j] = Royal.Scenes.Game.Utils.FlatLevel.FTiledSet.Pack(builder, _o.Sets[_j]); }
      _Sets = CreateSetsVector(builder, __Sets);
    }
    var _Colors = default(VectorOffset);
    if (_o.Colors != null) {
      var __Colors = _o.Colors.ToArray();
      _Colors = CreateColorsVector(builder, __Colors);
    }
    var _Counts = default(VectorOffset);
    if (_o.Counts != null) {
      var __Counts = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FItemCount>[_o.Counts.Count];
      for (var _j = 0; _j < __Counts.Length; ++_j) { __Counts[_j] = Royal.Scenes.Game.Utils.FlatLevel.FItemCount.Pack(builder, _o.Counts[_j]); }
      _Counts = CreateCountsVector(builder, __Counts);
    }
    var _PotionColors = default(VectorOffset);
    if (_o.PotionColors != null) {
      var __PotionColors = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FPotionColor>[_o.PotionColors.Count];
      for (var _j = 0; _j < __PotionColors.Length; ++_j) { __PotionColors[_j] = Royal.Scenes.Game.Utils.FlatLevel.FPotionColor.Pack(builder, _o.PotionColors[_j]); }
      _PotionColors = CreatePotionColorsVector(builder, __PotionColors);
    }
    var _LowMatch = default(VectorOffset);
    if (_o.LowMatch != null) {
      var __LowMatch = _o.LowMatch.ToArray();
      _LowMatch = CreateLowMatchVector(builder, __LowMatch);
    }
    var _Curtains = default(VectorOffset);
    if (_o.Curtains != null) {
      var __Curtains = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[_o.Curtains.Count];
      for (var _j = 0; _j < __Curtains.Length; ++_j) { __Curtains[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCurtainData.Pack(builder, _o.Curtains[_j]); }
      _Curtains = CreateCurtainsVector(builder, __Curtains);
    }
    var _CupShelves = default(VectorOffset);
    if (_o.CupShelves != null) {
      var __CupShelves = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[_o.CupShelves.Count];
      for (var _j = 0; _j < __CupShelves.Length; ++_j) { __CupShelves[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData.Pack(builder, _o.CupShelves[_j]); }
      _CupShelves = CreateCupShelvesVector(builder, __CupShelves);
    }
    var _SoilGroups = default(VectorOffset);
    if (_o.SoilGroups != null) {
      var __SoilGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[_o.SoilGroups.Count];
      for (var _j = 0; _j < __SoilGroups.Length; ++_j) { __SoilGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData.Pack(builder, _o.SoilGroups[_j]); }
      _SoilGroups = CreateSoilGroupsVector(builder, __SoilGroups);
    }
    var _Drills = default(VectorOffset);
    if (_o.Drills != null) {
      var __Drills = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FDrillData>[_o.Drills.Count];
      for (var _j = 0; _j < __Drills.Length; ++_j) { __Drills[_j] = Royal.Scenes.Game.Utils.FlatLevel.FDrillData.Pack(builder, _o.Drills[_j]); }
      _Drills = CreateDrillsVector(builder, __Drills);
    }
    var _LightBulbColorOrder = default(VectorOffset);
    if (_o.LightBulbColorOrder != null) {
      var __LightBulbColorOrder = _o.LightBulbColorOrder.ToArray();
      _LightBulbColorOrder = CreateLightBulbColorOrderVector(builder, __LightBulbColorOrder);
    }
    var _PouchConfig = _o.PouchConfig == null ? default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig>) : Royal.Scenes.Game.Utils.FlatLevel.FPouchConfig.Pack(builder, _o.PouchConfig);
    var _Limits = default(VectorOffset);
    if (_o.Limits != null) {
      var __Limits = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FLimitData>[_o.Limits.Count];
      for (var _j = 0; _j < __Limits.Length; ++_j) { __Limits[_j] = Royal.Scenes.Game.Utils.FlatLevel.FLimitData.Pack(builder, _o.Limits[_j]); }
      _Limits = CreateLimitsVector(builder, __Limits);
    }
    var _Treasuremaps = default(VectorOffset);
    if (_o.Treasuremaps != null) {
      var __Treasuremaps = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[_o.Treasuremaps.Count];
      for (var _j = 0; _j < __Treasuremaps.Length; ++_j) { __Treasuremaps[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData.Pack(builder, _o.Treasuremaps[_j]); }
      _Treasuremaps = CreateTreasuremapsVector(builder, __Treasuremaps);
    }
    var _Slots = default(VectorOffset);
    if (_o.Slots != null) {
      var __Slots = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig>[_o.Slots.Count];
      for (var _j = 0; _j < __Slots.Length; ++_j) { __Slots[_j] = Royal.Scenes.Game.Utils.FlatLevel.FSlotConfig.Pack(builder, _o.Slots[_j]); }
      _Slots = CreateSlotsVector(builder, __Slots);
    }
    var _MagnetGroups = default(VectorOffset);
    if (_o.MagnetGroups != null) {
      var __MagnetGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[_o.MagnetGroups.Count];
      for (var _j = 0; _j < __MagnetGroups.Length; ++_j) { __MagnetGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData.Pack(builder, _o.MagnetGroups[_j]); }
      _MagnetGroups = CreateMagnetGroupsVector(builder, __MagnetGroups);
    }
    var _ConveyorBelts = default(VectorOffset);
    if (_o.ConveyorBelts != null) {
      var __ConveyorBelts = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[_o.ConveyorBelts.Count];
      for (var _j = 0; _j < __ConveyorBelts.Length; ++_j) { __ConveyorBelts[_j] = Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData.Pack(builder, _o.ConveyorBelts[_j]); }
      _ConveyorBelts = CreateConveyorBeltsVector(builder, __ConveyorBelts);
    }
    var _Coils = default(VectorOffset);
    if (_o.Coils != null) {
      var __Coils = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCurtainData>[_o.Coils.Count];
      for (var _j = 0; _j < __Coils.Length; ++_j) { __Coils[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCurtainData.Pack(builder, _o.Coils[_j]); }
      _Coils = CreateCoilsVector(builder, __Coils);
    }
    var _CandyCaneGroups = default(VectorOffset);
    if (_o.CandyCaneGroups != null) {
      var __CandyCaneGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[_o.CandyCaneGroups.Count];
      for (var _j = 0; _j < __CandyCaneGroups.Length; ++_j) { __CandyCaneGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData.Pack(builder, _o.CandyCaneGroups[_j]); }
      _CandyCaneGroups = CreateCandyCaneGroupsVector(builder, __CandyCaneGroups);
    }
    var _TabletItemGroups = default(VectorOffset);
    if (_o.TabletItemGroups != null) {
      var __TabletItemGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData>[_o.TabletItemGroups.Count];
      for (var _j = 0; _j < __TabletItemGroups.Length; ++_j) { __TabletItemGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FCellGroupData.Pack(builder, _o.TabletItemGroups[_j]); }
      _TabletItemGroups = CreateTabletItemGroupsVector(builder, __TabletItemGroups);
    }
    var _IvyItemGroups = default(VectorOffset);
    if (_o.IvyItemGroups != null) {
      var __IvyItemGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData>[_o.IvyItemGroups.Count];
      for (var _j = 0; _j < __IvyItemGroups.Length; ++_j) { __IvyItemGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupData.Pack(builder, _o.IvyItemGroups[_j]); }
      _IvyItemGroups = CreateIvyItemGroupsVector(builder, __IvyItemGroups);
    }
    var _BlindsGroups = default(VectorOffset);
    if (_o.BlindsGroups != null) {
      var __BlindsGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData>[_o.BlindsGroups.Count];
      for (var _j = 0; _j < __BlindsGroups.Length; ++_j) { __BlindsGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupData.Pack(builder, _o.BlindsGroups[_j]); }
      _BlindsGroups = CreateBlindsGroupsVector(builder, __BlindsGroups);
    }
    var _WaterData = _o.WaterData == null ? default(Offset<Royal.Scenes.Game.Utils.FlatLevel.FWaterData>) : Royal.Scenes.Game.Utils.FlatLevel.FWaterData.Pack(builder, _o.WaterData);
    var _ShifterGrids = default(VectorOffset);
    if (_o.ShifterGrids != null) {
      var __ShifterGrids = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FShifterData>[_o.ShifterGrids.Count];
      for (var _j = 0; _j < __ShifterGrids.Length; ++_j) { __ShifterGrids[_j] = Royal.Scenes.Game.Utils.FlatLevel.FShifterData.Pack(builder, _o.ShifterGrids[_j]); }
      _ShifterGrids = CreateShifterGridsVector(builder, __ShifterGrids);
    }
    var _PorcelainGroups = default(VectorOffset);
    if (_o.PorcelainGroups != null) {
      var __PorcelainGroups = new Offset<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData>[_o.PorcelainGroups.Count];
      for (var _j = 0; _j < __PorcelainGroups.Length; ++_j) { __PorcelainGroups[_j] = Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupData.Pack(builder, _o.PorcelainGroups[_j]); }
      _PorcelainGroups = CreatePorcelainGroupsVector(builder, __PorcelainGroups);
    }
    return CreateFTiledLevel(
      builder,
      _Name,
      _o.Move,
      _Goals,
      _Grid,
      _Predefined,
      _Sets,
      _Colors,
      _Counts,
      _PotionColors,
      _LowMatch,
      _Curtains,
      _CupShelves,
      _SoilGroups,
      _Drills,
      _LightBulbColorOrder,
      _o.ChainCount,
      _o.PropellerIgnoresChain,
      _PouchConfig,
      _Limits,
      _o.PropellerIgnoresDrill,
      _o.JellyReceivableCellCount,
      _o.HasHoleInGrid,
      _Treasuremaps,
      _Slots,
      _o.CageCount,
      _MagnetGroups,
      _o.Scroll,
      _ConveyorBelts,
      _Coils,
      _CandyCaneGroups,
      _TabletItemGroups,
      _IvyItemGroups,
      _BlindsGroups,
      _WaterData,
      _ShifterGrids,
      _PorcelainGroups);
  }
}

public class FTiledLevelT
{
  [Newtonsoft.Json.JsonProperty("Name")]
  public string Name { get; set; }
  [Newtonsoft.Json.JsonProperty("Move")]
  public int Move { get; set; }
  [Newtonsoft.Json.JsonProperty("Goals")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FGoalDataT> Goals { get; set; }
  [Newtonsoft.Json.JsonProperty("Grid")]
  public Royal.Scenes.Game.Utils.FlatLevel.FTiledGridT Grid { get; set; }
  [Newtonsoft.Json.JsonProperty("Predefined")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefinedT> Predefined { get; set; }
  [Newtonsoft.Json.JsonProperty("Sets")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FTiledSetT> Sets { get; set; }
  [Newtonsoft.Json.JsonProperty("Colors")]
  public List<int> Colors { get; set; }
  [Newtonsoft.Json.JsonProperty("Counts")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FItemCountT> Counts { get; set; }
  [Newtonsoft.Json.JsonProperty("PotionColors")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FPotionColorT> PotionColors { get; set; }
  [Newtonsoft.Json.JsonProperty("LowMatch")]
  public List<int> LowMatch { get; set; }
  [Newtonsoft.Json.JsonProperty("Curtains")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataT> Curtains { get; set; }
  [Newtonsoft.Json.JsonProperty("CupShelves")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT> CupShelves { get; set; }
  [Newtonsoft.Json.JsonProperty("SoilGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT> SoilGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("Drills")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FDrillDataT> Drills { get; set; }
  [Newtonsoft.Json.JsonProperty("LightBulbColorOrder")]
  public List<int> LightBulbColorOrder { get; set; }
  [Newtonsoft.Json.JsonProperty("ChainCount")]
  public int ChainCount { get; set; }
  [Newtonsoft.Json.JsonProperty("PropellerIgnoresChain")]
  public bool PropellerIgnoresChain { get; set; }
  [Newtonsoft.Json.JsonProperty("PouchConfig")]
  public Royal.Scenes.Game.Utils.FlatLevel.FPouchConfigT PouchConfig { get; set; }
  [Newtonsoft.Json.JsonProperty("Limits")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FLimitDataT> Limits { get; set; }
  [Newtonsoft.Json.JsonProperty("PropellerIgnoresDrill")]
  public bool PropellerIgnoresDrill { get; set; }
  [Newtonsoft.Json.JsonProperty("JellyReceivableCellCount")]
  public int JellyReceivableCellCount { get; set; }
  [Newtonsoft.Json.JsonProperty("HasHoleInGrid")]
  public bool HasHoleInGrid { get; set; }
  [Newtonsoft.Json.JsonProperty("Treasuremaps")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT> Treasuremaps { get; set; }
  [Newtonsoft.Json.JsonProperty("Slots")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FSlotConfigT> Slots { get; set; }
  [Newtonsoft.Json.JsonProperty("CageCount")]
  public int CageCount { get; set; }
  [Newtonsoft.Json.JsonProperty("MagnetGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT> MagnetGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("Scroll")]
  public bool Scroll { get; set; }
  [Newtonsoft.Json.JsonProperty("ConveyorBelts")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT> ConveyorBelts { get; set; }
  [Newtonsoft.Json.JsonProperty("Coils")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataT> Coils { get; set; }
  [Newtonsoft.Json.JsonProperty("CandyCaneGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT> CandyCaneGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("TabletItemGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataT> TabletItemGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("IvyItemGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataT> IvyItemGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("BlindsGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupDataT> BlindsGroups { get; set; }
  [Newtonsoft.Json.JsonProperty("WaterData")]
  public Royal.Scenes.Game.Utils.FlatLevel.FWaterDataT WaterData { get; set; }
  [Newtonsoft.Json.JsonProperty("ShifterGrids")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FShifterDataT> ShifterGrids { get; set; }
  [Newtonsoft.Json.JsonProperty("PorcelainGroups")]
  public List<Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupDataT> PorcelainGroups { get; set; }

  public FTiledLevelT() {
    this.Name = null;
    this.Move = 0;
    this.Goals = null;
    this.Grid = null;
    this.Predefined = null;
    this.Sets = null;
    this.Colors = null;
    this.Counts = null;
    this.PotionColors = null;
    this.LowMatch = null;
    this.Curtains = null;
    this.CupShelves = null;
    this.SoilGroups = null;
    this.Drills = null;
    this.LightBulbColorOrder = null;
    this.ChainCount = 0;
    this.PropellerIgnoresChain = false;
    this.PouchConfig = null;
    this.Limits = null;
    this.PropellerIgnoresDrill = false;
    this.JellyReceivableCellCount = 0;
    this.HasHoleInGrid = false;
    this.Treasuremaps = null;
    this.Slots = null;
    this.CageCount = 0;
    this.MagnetGroups = null;
    this.Scroll = false;
    this.ConveyorBelts = null;
    this.Coils = null;
    this.CandyCaneGroups = null;
    this.TabletItemGroups = null;
    this.IvyItemGroups = null;
    this.BlindsGroups = null;
    this.WaterData = null;
    this.ShifterGrids = null;
    this.PorcelainGroups = null;
  }

  public static FTiledLevelT DeserializeFromJson(string jsonText) {
    return Newtonsoft.Json.JsonConvert.DeserializeObject<FTiledLevelT>(jsonText);
  }
  public string SerializeToJson() {
    return Newtonsoft.Json.JsonConvert.SerializeObject(this, Newtonsoft.Json.Formatting.Indented);
  }
  public static FTiledLevelT DeserializeFromBinary(byte[] fbBuffer) {
    return FTiledLevel.GetRootAsFTiledLevel(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    FTiledLevel.FinishFTiledLevelBuffer(fbb, FTiledLevel.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}


static public class FTiledLevelVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyString(tablePos, 4 /*Name*/, false)
      && verifier.VerifyField(tablePos, 6 /*Move*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfTables(tablePos, 8 /*Goals*/, Royal.Scenes.Game.Utils.FlatLevel.FGoalDataVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 10 /*Grid*/, Royal.Scenes.Game.Utils.FlatLevel.FTiledGridVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 12 /*Predefined*/, Royal.Scenes.Game.Utils.FlatLevel.FTiledPredefinedVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 14 /*Sets*/, Royal.Scenes.Game.Utils.FlatLevel.FTiledSetVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 16 /*Colors*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 18 /*Counts*/, Royal.Scenes.Game.Utils.FlatLevel.FItemCountVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 20 /*PotionColors*/, Royal.Scenes.Game.Utils.FlatLevel.FPotionColorVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 22 /*LowMatch*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 24 /*Curtains*/, Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 26 /*CupShelves*/, Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 28 /*SoilGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 30 /*Drills*/, Royal.Scenes.Game.Utils.FlatLevel.FDrillDataVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 32 /*LightBulbColorOrder*/, 4 /*int*/, false)
      && verifier.VerifyField(tablePos, 34 /*ChainCount*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 36 /*PropellerIgnoresChain*/, 1 /*bool*/, 1, false)
      && verifier.VerifyTable(tablePos, 38 /*PouchConfig*/, Royal.Scenes.Game.Utils.FlatLevel.FPouchConfigVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 40 /*Limits*/, Royal.Scenes.Game.Utils.FlatLevel.FLimitDataVerify.Verify, false)
      && verifier.VerifyField(tablePos, 42 /*PropellerIgnoresDrill*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 44 /*JellyReceivableCellCount*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 46 /*HasHoleInGrid*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 48 /*Treasuremaps*/, Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 50 /*Slots*/, Royal.Scenes.Game.Utils.FlatLevel.FSlotConfigVerify.Verify, false)
      && verifier.VerifyField(tablePos, 52 /*CageCount*/, 4 /*int*/, 4, false)
      && verifier.VerifyVectorOfTables(tablePos, 54 /*MagnetGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataVerify.Verify, false)
      && verifier.VerifyField(tablePos, 56 /*Scroll*/, 1 /*bool*/, 1, false)
      && verifier.VerifyVectorOfTables(tablePos, 58 /*ConveyorBelts*/, Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 60 /*Coils*/, Royal.Scenes.Game.Utils.FlatLevel.FCurtainDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 62 /*CandyCaneGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 64 /*TabletItemGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FCellGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 66 /*IvyItemGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FMagnetGroupDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 68 /*BlindsGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FBlindsGroupDataVerify.Verify, false)
      && verifier.VerifyTable(tablePos, 70 /*WaterData*/, Royal.Scenes.Game.Utils.FlatLevel.FWaterDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 72 /*ShifterGrids*/, Royal.Scenes.Game.Utils.FlatLevel.FShifterDataVerify.Verify, false)
      && verifier.VerifyVectorOfTables(tablePos, 74 /*PorcelainGroups*/, Royal.Scenes.Game.Utils.FlatLevel.FDirectedPointGroupDataVerify.Verify, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
